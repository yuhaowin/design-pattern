代理模式

定义 :为其他对象提供一种代理,以控制对这个对象的访问;
代理对象在客户端和目标对象之间起到中介作用

我  -  中介  - 房东    中介 (代理)

aop  before after

类型:结构性

适用场景:  保护目标对象 
         增强目标对象
         
优点:

代理模式 可以将代理对象和真实调用的目标对象分离
一定程度上降低了系统的耦合性,扩展性好
保护目标对象 
增强目标对象  

缺点:
类数目增加
增加系统复杂度



分类:

静态代理 (在代码中显示指定的代理)
动态代理(在jdk中 动态代理只能对实现了接口的类生成代理,并不能针对一个具体的实现类进行代理)    
动态代理无法代理类,只能代理接口
jdk 动态代理中 用到了的代理类是在程序调用到代理类对象时,  才有jvm真正创建,jvm根据传入的真正的业务实现类对象以及方法名
动态的创建了一个代理类的class文件 ,这个class文件被字节码引擎执行,然后通过该代理类的对象进行方法的调用

需要做的是将代理类中的实现逻辑写好. 如before 和 after 的具体实现,  这些是对目标对象方法层次的增强 


如果业务实现类没有实现接口,而是直接定义方法的话,就无法使用jdk的动态代理

如果一个接口声明了两个方法  a() 和 b()
实现该接口的类只实现了 a方法和b方法, 这时如果在实现类中定义c方法 但是c没有在接口中声明,此时c方法也是无法被代理的.


cglib代理 cglib是可以代理类的,就是针对类实现进行代理

实现原理:如果代理一个类如:A类cglib会生成一个被代理类(A) 的子类,由子类覆盖父类中的方法,
注意,如果A类是final的那么A类就无法被继承, 如果A类不是final的,但是类中的方法是final的,被final修饰的方法是无法被重写的,
以上两种情况是无法使用cglib代理



Spring中的代理模式的选择(扩展内容)
+ 当bean有实现的接口时,Spring就用JDK的动态代理
+ 当bean没有实现接口时,Spring就用cglib的动态代理

也可以强制使用cglib代理模式 
![](https://ws2.sinaimg.cn/large/006tKfTcgy1g0aj1n8mopj31g80dadme.jpg)


两种动态代理的速度对比

cglib 底层原理是使用asm字节码生成 (使用asm比通过反射的效率要高)

在jdk7 和 jdk8  的原生的动态代理 不cglib快大约20%


相关的设计模式:

代理模式和装饰者模式
装饰者模式:是为对象加上行为
代理模式: 控制访问,是为了增强目标对象,增强目标对象的方式是:增强目标对象的某些行为. 

代理模式和适配器模式
适配器模式主要考虑和改变对象的接口,
代理模式不能改变代理类的接口的.



源码 jdkDynamicAopProxy   cglibAopProxy  ProxyFactoryBean(package org.springframework.aop.framework)

mybatis  使用的是jdk的原生的动态代理
MapperProxyFactory  MapperProxy

https://blog.csdn.net/iteye_2730/article/details/82398231